#PUNTO 1
void algoritmo1(int n){ 
    int i, j = 1;                                   #1
    for(i = n * n; i > 0; i = i / 2){               #〖 log〗_2⁡〖〖(n〗^2 〗)+2
           int suma = i + j;                        #〖 log〗_2⁡〖〖(n〗^2 〗)+1
           printf("Suma %d\n", suma);               #〖 log〗_2⁡〖〖(n〗^2 〗)+1
           ++j;                                     #〖 log〗_2⁡〖〖(n〗^2 〗)+1
      }
}

T(n) = 1+  〖 (log〗_2⁡〖〖(n〗^2 〗)+2)+〖 (log〗_2⁡〖〖(n〗^2 〗)+1)+〖 (log〗_2⁡〖〖(n〗^2 〗)+1)+〖 (log〗_2⁡〖〖(n〗^2 〗)+1)

T(n) = 4 log_2⁡〖n^2 〗+6 ∈O(log_2⁡〖n^2 〗)

#Al ejecutar el algoritmo1(8) se obtiene:

#Suma 65
#Suma 34
#Suma 19
#Suma 12
#Suma 9
#Suma 8
#Suma 8

#En cada línea se obtiene la suma del valor de i; siendo i inicialmente n*n y dividiéndose entre 2 enteramente en cada iteración hasta que llegue a 0,  más la cantidad de iteraciones realizadas en el instante.





#PUNTO 2

int algoritmo2(int n){
       int res = 1, i, j;                       # 1
       for(i = 1; i <= 2 * n; i += 4)           # n/2+1
               for(j = 1; j * j <= n; j++)    #  n/2*((√(2&n))+1)
                     res += 2;                  #  n/2*(√(2&n))
       return res;
}
T(n) = (n/2+2)+(n/2*((√(2&n))+1))+(n/2*(√(2&n)))
T(n) =  n+(1+√(2&n))+2=n+n√(2&n)+2 ∈O(n√(2&n))

#Al ejecutar el algoritmo2(8) se obtiene:

#17
 
#Este valor se obtiene al sumar  n/2*(√(2&n)) veces 2 a una variable que inicia en 1.




#PUNTO 3

void algoritmo3(int n){
      int i, j, k;                                   # 1
      for(i = n; i > 1; i--)                         # (n-1)+1
            for(j = 1; j <= n; j++)                  # (n-1)*(n+1)
                   for(k = 1; k <= i; k++)           # ∑_(i=1)^(n-1)▒〖n*(i+2)〗
                        printf("Vida cruel!!\n");    # ∑_(i=1)^(n-1)▒〖n*(i+1)〗
}
T(n) = 1+((n-1)+1)+((n-1)*(n+1))+(∑_(i=1)^(n-1)▒〖n*(i+2)〗)+(∑_(i=1)^(n-1)▒〖n*(i+1)〗)
T(n) = 1+((n-1)+1)+((n-1)*(n+1))+(n∑_(i=1)^(n-1)▒〖(i+2)〗)+(n∑_(i=1)^(n-1)▒〖(i+1)〗)
T(n) = 1+((n-1)+1)+((n-1)*(n+1))+(n∑_(i=1)^(n-1)▒〖(i+2)〗)+(n∑_(i=1)^(n-1)▒〖(i+1)〗)
T(n) = 1+((n-1)+1)+((n-1)*(n+1))+(n(2(n-1)+(n-1)n/2))+(n((n-1)+(n-1)n/2))
T(n) =n^3+3n^2-2n = O(n^3 )






#PUNTO 4
int algoritmo4(int* valores, int n){ 
      int suma = 0, contador = 0;   # 2
      int i, j, h, flag;   # 4
      for(i = 0; i < n; i++){   # n + 1
          j = i + 1;   #n
          flag = 0;   # n
          while(j < n && flag == 0){  # ∑_(i = o)^(n-1)▒i+2
                if(valores[i] < valores[j]){# ∑_(i = o)^(n-1)▒i+1
                      for(h = j; h < n; h++){ # ∑_(i = o)^(n-1)▒∑_(l = o)^(n-1)▒l+2
                            suma += valores[i]; #∑_(i = o)^(n-1)▒∑_(l = o)^(n-1)▒l+1
                      } 
                 } 
                 else{ #∑_(i = o)^(n-1)▒i+1
                        contador++; flag = 1; #∑_(i = o)^(n-1)▒i+1
                 } 
                 ++j; #∑_(i = o)^(n-1)▒i+1
           } 
     } 
     return contador;  # 1
}

T(n) = O(n^3)
#Esto se debe a que en el peor de los casos cada ciclo se ejecutaría n veces, al ser ciclos anidados terminaría multiplicando la complejidad de cada uno, terminando en el ciclo más interno n*n*n





#PUNTO 5
void algoritmo5(int n){
       int i = 0;  # 1 
       while(i <= n){  # n/5+2
               printf("%d\n", i); # n/5+1
               i += n / 5; #n/5+1
         } 
}
T(n) = 1+(n/5+2)+(n/5+1)+(n/5+1)
T(n) = 3n/5+2
}
T(n) = 3/5 n+2 ∈ O(n)




#PUNTO 6
def algoritmo6(n):
  	if n <= 1: # 1 
         return n #1
    else: #1
         return(algoritmo6 (n-1) + algoritmo6 (n-2)) # 2^n
T(n) = 2^n+2 = O(2^n)
#Esto se debe a que se llama a sí misma 2 veces para cada índice al que se le quiera hacer análisis de su número Fibonacci, a excepción de los casos bases 0 y 1.

#Al completar la tabla tenemos que:
#El tamaño de entrada: 5 tiene un tiempo de 0.000008 seg
#El tamaño de entrada: 10 tiene un tiempo de 0.00006 seg
#El tamaño de entrada: 15 tiene un tiempo de 0.0004
#El tamaño de entrada: 20 tiene un tiempo de 0.004 seg
#El tamaño de entrada: 25 tiene un tiempo de 0.1 seg
#El tamaño de entrada: 30 tiene un tiempo de 1.2 seg
#El tamaño de entrada: 35 tiene iun tiempo de 15.7 seg
#El tamaño de entrada: 40 - 45 - 50 - 60 - 100 no termina

#El valor más alto obtenido es de 15.7 segundos para una entrada de 35, esto ocurre al ser un algoritmo con un crecimiento de 2^n, lo que significa que para el tamaño de 40 el tiempo que necesitará será de 15⋅32 segundos, resultando así que tomará 8 minutos en resolverse




#PUNTO 7

def recur_fibo(n):
   sol = 0   # 1
   if n == 1:  # 1
        sol = 1   # 1
elif n == 0:   # 1
sol = 0   # 1
else:   # 1
a = 1  # 1
    		b = 0  # 1
    		sol = 0  # 1
   		for i in range(2,n+1):  # (n-1) + 1
      	sol = a  # (n-1)
     	 a = a + b  # (n-1)
     	b = sol  # (n-1)
sol = a # 1
return sol # 1
T(n) = 4n+8 = O(n)


