#PUNTO 1
void algoritmo1(int n){ 
    int i, j = 1;                                   #1
    for(i = n * n; i > 0; i = i / 2){               #〖 log〗_2⁡〖〖(n〗^2 〗)+2
           int suma = i + j;                        #〖 log〗_2⁡〖〖(n〗^2 〗)+1
           printf("Suma %d\n", suma);               #〖 log〗_2⁡〖〖(n〗^2 〗)+1
           ++j;                                     #〖 log〗_2⁡〖〖(n〗^2 〗)+1
      }
}

T(n) = 1+  〖 (log〗_2⁡〖〖(n〗^2 〗)+2)+〖 (log〗_2⁡〖〖(n〗^2 〗)+1)+〖 (log〗_2⁡〖〖(n〗^2 〗)+1)+〖 (log〗_2⁡〖〖(n〗^2 〗)+1)

T(n) = 4 log_2⁡〖n^2 〗+6 ∈O(log_2⁡〖n^2 〗)

Al ejecutar el algoritmo1(8) se obtiene:

Suma 65
Suma 34
Suma 19
Suma 12
Suma 9
Suma 8
Suma 8

En cada línea se obtiene la suma del valor de i; siendo i inicialmente n*n y dividiéndose entre 2 enteramente en cada iteración hasta que llegue a 0,  más la cantidad de iteraciones realizadas en el instante.





#PUNTO 2

int algoritmo2(int n){
       int res = 1, i, j;                       # 1
       for(i = 1; i <= 2 * n; i += 4)           # n/2+1
               for(j = 1; j * j <= n; j++)    #  n/2*((√(2&n))+1)
                     res += 2;                  #  n/2*(√(2&n))
       return res;
}
T(n) = (n/2+2)+(n/2*((√(2&n))+1))+(n/2*(√(2&n)))
T(n) =  n+(1+√(2&n))+2=n+n√(2&n)+2 ∈O(n√(2&n))

Al ejecutar el algoritmo2(8) se obtiene:

17
 
Este valor se obtiene al sumar  n/2*(√(2&n)) veces 2 a una variable que inicia en 1.




#PUNTO 3

void algoritmo3(int n){
      int i, j, k;                                   # 1
      for(i = n; i > 1; i--)                         # (n-1)+1
            for(j = 1; j <= n; j++)                  # (n-1)*(n+1)
                   for(k = 1; k <= i; k++)           # ∑_(i=1)^(n-1)▒〖n*(i+2)〗
                        printf("Vida cruel!!\n");    # ∑_(i=1)^(n-1)▒〖n*(i+1)〗
}
T(n) = 1+((n-1)+1)+((n-1)*(n+1))+(∑_(i=1)^(n-1)▒〖n*(i+2)〗)+(∑_(i=1)^(n-1)▒〖n*(i+1)〗)
T(n) = 1+((n-1)+1)+((n-1)*(n+1))+(n∑_(i=1)^(n-1)▒〖(i+2)〗)+(n∑_(i=1)^(n-1)▒〖(i+1)〗)
T(n) = 1+((n-1)+1)+((n-1)*(n+1))+(n∑_(i=1)^(n-1)▒〖(i+2)〗)+(n∑_(i=1)^(n-1)▒〖(i+1)〗)
T(n) = 1+((n-1)+1)+((n-1)*(n+1))+(n(2(n-1)+(n-1)n/2))+(n((n-1)+(n-1)n/2))
T(n) =n^3+3n^2-2n = O(n^3 )






#PUNTO 4
int algoritmo4(int* valores, int n){ 
      int suma = 0, contador = 0;   # 2
      int i, j, h, flag;   # 4
      for(i = 0; i < n; i++){   # n + 1
          j = i + 1;   #n
          flag = 0;   # n
          while(j < n && flag == 0){  # ∑_(i = o)^(n-1)▒i+2
                if(valores[i] < valores[j]){# ∑_(i = o)^(n-1)▒i+1
                      for(h = j; h < n; h++){ # ∑_(i = o)^(n-1)▒∑_(l = o)^(n-1)▒l+2
                            suma += valores[i]; #∑_(i = o)^(n-1)▒∑_(l = o)^(n-1)▒l+1
                      } 
                 } 
                 else{ #∑_(i = o)^(n-1)▒i+1
                        contador++; flag = 1; #∑_(i = o)^(n-1)▒i+1
                 } 
                 ++j; #∑_(i = o)^(n-1)▒i+1
           } 
     } 
     return contador;  # 1
}

T(n) = O(n^3)
Esto se debe a que en el peor de los casos cada ciclo se ejecutaría n veces, al ser ciclos anidados terminaría multiplicando la complejidad de cada uno, terminando en el ciclo más interno n*n*n





#PUNTO 5
void algoritmo5(int n){
       int i = 0;  # 1 
       while(i <= n){  # n/5+2
               printf("%d\n", i); # n/5+1
               i += n / 5; #n/5+1
         } 
}
T(n) = 1+(n/5+2)+(n/5+1)+(n/5+1)
T(n) = 3n/5+2
}
T(n) = 3/5 n+2 ∈ O(n)




#PUNTO 6

